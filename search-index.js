var searchIndex = {};
searchIndex["tk_http"] = {"doc":"Simple HTTP service based on `tokio` tools","items":[[4,"Version","tk_http","Enum reprsenting HTTP version.",null,null],[13,"Http10","","Version 1.0 of the HTTP protocol",0,null],[13,"Http11","","Version 1.1 of the HTTP protocol",0,null],[4,"Status","","Enum with some HTTP Status codes.",null,null],[13,"Continue","","",1,null],[13,"SwitchingProtocol","","",1,null],[13,"Ok","","",1,null],[13,"Created","","",1,null],[13,"Accepted","","",1,null],[13,"NonAuthoritativeInformation","","",1,null],[13,"NoContent","","",1,null],[13,"ResetContent","","",1,null],[13,"PartialContent","","",1,null],[13,"MultipleChoices","","",1,null],[13,"MovedPermanently","","",1,null],[13,"Found","","",1,null],[13,"SeeOther","","",1,null],[13,"NotModified","","",1,null],[13,"UseProxy","","",1,null],[13,"TemporaryRedirect","","",1,null],[13,"PermanentRedirect","","",1,null],[13,"BadRequest","","",1,null],[13,"Unauthorized","","",1,null],[13,"PaymentRequired","","",1,null],[13,"Forbidden","","",1,null],[13,"NotFound","","",1,null],[13,"MethodNotAllowed","","",1,null],[13,"NotAcceptable","","",1,null],[13,"ProxyAuthenticationRequired","","",1,null],[13,"RequestTimeout","","",1,null],[13,"Conflict","","",1,null],[13,"Gone","","",1,null],[13,"LengthRequired","","",1,null],[13,"PreconditionFailed","","",1,null],[13,"RequestEntityTooLarge","","",1,null],[13,"RequestURITooLong","","",1,null],[13,"UnsupportedMediaType","","",1,null],[13,"RequestRangeNotSatisfiable","","",1,null],[13,"ExpectationFailed","","",1,null],[13,"UpgradeRequired","","",1,null],[13,"TooManyRequests","","",1,null],[13,"InternalServerError","","",1,null],[13,"NotImplemented","","",1,null],[13,"BadGateway","","",1,null],[13,"ServiceUnavailable","","",1,null],[13,"GatewayTimeout","","",1,null],[13,"VersionNotSupported","","",1,null],[0,"server","","HTTP server protocol implementation",null,null],[3,"Error","tk_http::server","HTTP server error",null,null],[3,"Encoder","","This a response writer that you receive in `Codec`",null,null],[3,"EncoderDone","","This structure returned from `Encoder::done` and works as a continuation\nthat should be returned from the future that writes request.",null,null],[3,"FutureRawBody","","A future that yields `RawBody` after buffer is empty",null,null],[3,"RawBody","","The actual raw body",null,null],[3,"Proto","","A low-level HTTP/1.x server protocol handler",null,null],[3,"Head","","A borrowed structure that represents request headers",null,null],[3,"HeaderIter","","Iterator over all meaningful headers for the request",null,null],[3,"WebsocketHandshake","","Contains all the imporant parts of a websocket handshake",null,null],[12,"accept","","The destination value of `Sec-WebSocket-Accept`",2,null],[12,"protocols","","List of `Sec-WebSocket-Protocol` tokens",2,null],[12,"extensions","","List of `Sec-WebSocket-Extensions` tokens",2,null],[3,"Config","","Fine-grained configuration of the HTTP server",null,null],[3,"RecvMode","","This type is returned from `headers_received` handler of either\nclient client or server protocol handler",null,null],[4,"RequestTarget","","A middle part of the request line",null,null],[13,"Origin","","Usual form of `/hello?name=world`",3,null],[13,"Absolute","","Full url: `http://example.com:8080/hello`",3,null],[12,"scheme","tk_http::server::RequestTarget","Scheme, might be `http` or `https` (latter is useless for now)",3,null],[12,"authority","","Authority is basically `host[:port]`",3,null],[12,"path","","Path relative to root, it&#39;s not normalized, so might be empty",3,null],[13,"Authority","tk_http::server","Only hostname `example.com:8080`, only useful for `CONNECT` method",3,null],[13,"Asterisk","","Asterisk `*`",3,null],[11,"new","","Create a config with defaults",4,{"inputs":[],"output":{"name":"config"}}],[11,"inflight_request_limit","","A number of inflight requests until we stop reading more requests",4,null],[11,"inflight_request_prealoc","","Size of the queue that is preallocated for holding requests",4,null],[11,"done","","Create a Arc&#39;d config clone to pass to the constructor",4,null],[11,"first_byte_timeout","","Timeout receiving very first byte over connection",4,null],[11,"keep_alive_timeout","","Timeout of idle connection (when no request has been sent yet)",4,null],[11,"headers_timeout","","Timeout of receiving whole request headers",4,null],[11,"input_body_byte_timeout","","Maximum delay between any two bytes of input request received",4,null],[11,"input_body_whole_timeout","","Timeout of whole request body received",4,null],[11,"output_body_byte_timeout","","Maximum delay between any two bytes of the output request could be\nsent",4,null],[11,"output_body_whole_timeout","","Timeout for the whole response body to be send to the client",4,null],[11,"fmt","","",5,null],[11,"fmt","","",5,null],[11,"from","","",5,{"inputs":[{"name":"errorenum"}],"output":{"name":"self"}}],[11,"description","","",5,null],[11,"cause","","",5,null],[11,"custom","","Create an error instance wrapping custom error",5,{"inputs":[{"name":"e"}],"output":{"name":"error"}}],[11,"new","","Create a new protocol implementation from a TCP connection and a config",6,{"inputs":[{"name":"s"},{"name":"arc"},{"name":"d"},{"name":"handle"}],"output":{"name":"proto"}}],[11,"poll","","",6,null],[11,"as_raw_fd","","",7,null],[11,"response_continue","","Write a 100 (Continue) response.",8,null],[11,"status","","Write status line using `Status` enum",8,null],[11,"custom_status","","Write custom status line",8,null],[11,"add_header","","Add a header to the message.",8,null],[11,"format_header","","Same as `add_header` but allows value to be formatted directly into\nthe buffer",8,null],[11,"add_length","","Add a content length to the message.",8,null],[11,"add_chunked","","Sets the transfer encoding to chunked.",8,null],[11,"is_started","","Returns true if at least `status()` method has been called",8,null],[11,"done_headers","","Closes the HTTP header and returns `true` if entity body is expected.",8,null],[11,"write_body","","Write a chunk of the message body.",8,null],[11,"is_complete","","Returns true if `done()` method is already called and everything\nwas okay.",8,null],[11,"done","","Writes needed finalization data into the buffer and asserts\nthat response is in the appropriate state for that.",8,null],[11,"raw_body","","Returns a raw body for zero-copy writing techniques",8,null],[11,"done","","Returns `EncoderDone` object that might be passed back to the HTTP\nprotocol",7,null],[11,"write","","",8,null],[11,"flush","","",8,null],[11,"write","","",7,null],[11,"flush","","",7,null],[11,"poll","","",9,null],[11,"fmt","","",3,null],[11,"fmt","","",10,null],[11,"method","","Returns a HTTP method",10,null],[11,"request_target","","Request-target (the middle part of the first line of request)",10,null],[11,"raw_request_target","","Returns a raw request target as string",10,null],[11,"path","","Returns path portion of request uri",10,null],[11,"host","","Return host of a request",10,null],[11,"has_conflicting_host","","Returns true if `Host` header conflicts with host in request-uri",10,null],[11,"version","","Version of HTTP request",10,null],[11,"headers","","Iterator over the headers of HTTP request",10,null],[11,"all_headers","","All headers of HTTP request",10,null],[11,"connection_close","","Return `true` if `Connection: close` header exists",10,null],[11,"connection_header","","Returns the value of the `Connection` header (all of them, if multiple)",10,null],[11,"has_body","","Returns true if there was transfer-encoding or content-length != 0",10,null],[11,"body_length","","Returns size of the request body if either `Content-Length` is set\nor it is safe to assume that request body is zero-length",10,null],[11,"get_websocket_upgrade","","Check if connection is a websocket and return hanshake info",10,null],[11,"next","","",11,null],[11,"fmt","","",2,null],[11,"buffered_upfront","","Download whole message body (request or response) into the memory\nbefore starting response",12,{"inputs":[{"name":"usize"}],"output":{"name":"recvmode"}}],[11,"progressive","","Fetch data chunk-by-chunk.",12,{"inputs":[{"name":"usize"}],"output":{"name":"recvmode"}}],[11,"hijack","","Don&#39;t read request body and hijack connection after response headers\nare sent. Useful for connection upgrades, including websockets and\nfor CONNECT method.",12,{"inputs":[],"output":{"name":"recvmode"}}],[11,"body_read_timeout","","Change timeout for reading the whole request body to this value\ninstead of configured default",12,null],[0,"buffered","","Higher-level interface for serving fully buffered requests",null,null],[3,"Request","tk_http::server::buffered","Buffered request struct",null,null],[3,"BufferedDispatcher","","A dispatcher that allows to process request and return response using\na one single function",null,null],[3,"BufferedCodec","","A codec counterpart of the BufferedDispatcher, might be used with your\nown dispatcher too",null,null],[3,"WebsocketFactory","","A helper to create a simple websocket (and HTTP) service",null,null],[3,"WebsocketService","","An instance of websocket factory, created by WebsocketFactory itself",null,null],[8,"NewService","","A trait that you must implement to reply on requests, usually a function",null,null],[16,"Future","","Future returned by the service (an actual function serving request)",13,null],[16,"Instance","","Instance of the service, created for each request",13,null],[10,"new","","Constructor of the instance of the service, created for each request",13,null],[8,"Service","","An instance of a NewService for a single request, usually just a function",null,null],[16,"Future","","A future returned by `call()`",14,null],[16,"WebsocketFuture","","A future returned by `start_websocket`, it&#39;s spawned on the main loop\nhence needed to be static.",14,null],[10,"call","","A method which is called when request arrives, including the websocket\nnegotiation request.",14,null],[10,"start_websocket","","A method which is called when websocket connection established",14,null],[11,"fmt","","",15,null],[11,"new","","",16,null],[11,"call","","",17,null],[11,"start_websocket","","",17,null],[11,"peer_addr","","Returns peer address that initiated HTTP connection",15,null],[11,"method","","Returns method of a request",15,null],[11,"path","","Returns path of a request",15,null],[11,"version","","Returns HTTP version used in request",15,null],[11,"headers","","Returns request headers",15,null],[11,"body","","Returns request body",15,null],[11,"websocket_handshake","","Returns websocket handshake if exists",15,null],[11,"new","","Create an instance of bufferd dispatcher",18,{"inputs":[{"name":"socketaddr"},{"name":"handle"},{"name":"n"}],"output":{"name":"buffereddispatcher"}}],[11,"max_request_length","","Sets max request length",18,null],[11,"new_with_websockets","","Creates a dispatcher with two functions: one serving http requests and\nwebsockets.",18,{"inputs":[{"name":"socketaddr"},{"name":"handle"},{"name":"h"},{"name":"i"}],"output":{"name":"buffereddispatcher"}}],[11,"headers_received","","",18,null],[11,"recv_mode","","",19,null],[11,"data_received","","",19,null],[11,"start_response","","",19,null],[11,"hijack","","",19,null],[8,"Codec","tk_http::server","The type represents a consumer of a single request and yields a writer of\na response (the latter is a ``ResponseFuture``",null,null],[16,"ResponseFuture","","This is a future returned by `start_response`",20,null],[10,"recv_mode","","Return a mode which will be used to receive request body",20,null],[10,"data_received","","Chunk of the response body received",20,null],[10,"start_response","","Start writing a response",20,null],[11,"hijack","","Called after future retunrted by `start_response` done if recv mode\nis `Hijack`",20,null],[8,"Dispatcher","","This is a low-level interface to the http server",null,null],[16,"Codec","","The codec type  for this dispatcher",21,null],[10,"headers_received","","Received headers of a request",21,null],[11,"fmt","","",4,null],[11,"clone","","",4,null],[11,"fmt","","",12,null],[11,"clone","","",12,null],[0,"client","tk_http","The HTTP/1.x client protocol implementation",null,null],[3,"Error","tk_http::client","HTTP client error",null,null],[3,"Encoder","","This a request writer that you receive in `Codec`",null,null],[3,"EncoderDone","","This structure returned from `Encoder::done` and works as a continuation\nthat should be returned from the future that writes request.",null,null],[3,"Proto","","A low-level HTTP/1.x client protocol handler",null,null],[3,"Config","","Fine-grained configuration of the HTTP connection",null,null],[3,"Head","","A borrowed structure that represents response headers",null,null],[3,"RecvMode","","This type is returned from `headers_received` handler of either\nclient client or server protocol handler",null,null],[11,"new","","Create a config with defaults",22,{"inputs":[],"output":{"name":"config"}}],[11,"inflight_request_limit","","A number of inflight requests until we start returning\n`NotReady` from `start_send`",22,null],[11,"inflight_request_prealoc","","Size of the queue that is preallocated for holding requests",22,null],[11,"keep_alive_timeout","","Keep-alive timeout",22,null],[11,"safe_pipeline_timeout","","Maximum time peer doesn&#39;t answer request before we consider this\nconnection can&#39;t be used for pipelining more requests.",22,null],[11,"max_request_timeout","","Absolute maximum time of whole request can work",22,null],[11,"done","","Create a Arc&#39;d config clone to pass to the constructor",22,null],[11,"request_line","","Write request line.",23,null],[11,"add_header","","Add a header to the message.",23,null],[11,"format_header","","Same as `add_header` but allows value to be formatted directly into\nthe buffer",23,null],[11,"add_length","","Add a content length to the message.",23,null],[11,"add_chunked","","Sets the transfer encoding to chunked.",23,null],[11,"done_headers","","Closes the HTTP header",23,null],[11,"write_body","","Write a chunk of body",23,null],[11,"done","","Finish writing request and return `EncoderDone` which can be moved to",23,null],[11,"write","","",23,null],[11,"flush","","",23,null],[11,"fmt","","",24,null],[11,"fmt","","",24,null],[11,"from","","",24,{"inputs":[{"name":"errorenum"}],"output":{"name":"self"}}],[11,"description","","",24,null],[11,"cause","","",24,null],[11,"custom","","Create an error instance wrapping custom error",24,{"inputs":[{"name":"e"}],"output":{"name":"error"}}],[11,"status","","Returns status if it is one of the supported statuses otherwise None",25,null],[11,"raw_status","","Returns raw status code and reason as received even",25,null],[11,"headers","","Iterator over the headers of HTTP request",25,null],[11,"all_headers","","All headers of HTTP request",25,null],[11,"new","","Create a new protocol implementation from a TCP connection and a config",26,{"inputs":[{"name":"s"},{"name":"handle"},{"name":"arc"}],"output":{"name":"proto"}}],[11,"connect_tcp","","A convenience method to establish connection and create a protocol\ninstance",26,{"inputs":[{"name":"socketaddr"},{"name":"arc"},{"name":"handle"}],"output":{"name":"box"}}],[11,"start_send","","",26,null],[11,"poll_complete","","",26,null],[11,"buffered","","Download whole message body (request or response) into the memory.",27,{"inputs":[{"name":"usize"}],"output":{"name":"recvmode"}}],[11,"progressive","","Fetch data chunk-by-chunk.",27,{"inputs":[{"name":"usize"}],"output":{"name":"recvmode"}}],[0,"buffered","","Simple to use wrappers for dealing with fully buffered requests",null,null],[3,"Buffered","tk_http::client::buffered","Fully buffered (in-memory) writing request and reading response",null,null],[3,"Response","","A buffered response holds contains a body as contiguous chunk of data",null,null],[11,"fmt","","",28,null],[11,"status","","Get response status",28,null],[11,"headers","","Get response headers",28,null],[11,"body","","Get response body",28,null],[11,"start_write","","",29,null],[11,"headers_received","","",29,null],[11,"data_received","","",29,null],[11,"get","","Fetch data from url using GET method, fully buffered",29,null],[11,"max_response_length","","Set max response length for this buffered reader",29,null],[8,"Client","tk_http::client","A marker trait that applies to a Sink that is essentially a HTTP client",null,null],[10,"fetch_url","","Simple fetch helper",30,null],[8,"Codec","","This is a low-level interface to the http client",null,null],[16,"Future","","Future that `start_write()` returns",31,null],[10,"start_write","","Start writing a request",31,null],[10,"headers_received","","Received headers of a response",31,null],[10,"data_received","","Chunk of the response body received",31,null],[11,"fmt","","",22,null],[11,"clone","","",22,null],[11,"fmt","","",25,null],[11,"fmt","","",27,null],[11,"clone","","",27,null],[0,"websocket","tk_http","Websocket support stuff",null,null],[3,"ServerCodec","tk_http::websocket","Websocket codec for use with tk-bufstream in `Codec::hijack()`",null,null],[3,"ClientCodec","","Websocket codec for use with tk-bufstream",null,null],[3,"Loop","","This is a helper for running websockets",null,null],[3,"Error","","Websocket Error works both for client and server connections",null,null],[3,"Accept","","The `Sec-WebSocket-Accept` header value",null,null],[3,"Key","","The `Sec-WebSocket-Key` header value",null,null],[3,"Config","","Configuration of a `websocket::Loop` object (a server-side websocket\nconnection).",null,null],[4,"Packet","","A websocket packet",null,null],[13,"Ping","","Ping packet (with data)",32,null],[13,"Pong","","Pong packet (with data)",32,null],[13,"Text","","Text (utf-8) messsage",32,null],[13,"Binary","","Binary message",32,null],[13,"Close","","Close message",32,null],[4,"Frame","","A borrowed frame of websocket data",null,null],[13,"Ping","","Ping mesage",33,null],[13,"Pong","","Pong mesage",33,null],[13,"Text","","Text (utf-8) message",33,null],[13,"Binary","","Binary message",33,null],[13,"Close","","Close message",33,null],[11,"fmt","","",32,null],[11,"clone","","",32,null],[11,"encode","","",34,null],[11,"decode","","",34,null],[11,"encode","","",35,null],[11,"decode","","",35,null],[11,"new","","Create a config with defaults",36,{"inputs":[],"output":{"name":"config"}}],[11,"ping_interval","","Set ping interval",36,null],[11,"inactivity_timeout","","Set inactivity timeout",36,null],[11,"max_packet_size","","Maximum packet size",36,null],[11,"done","","Create a Arc&#39;d config clone to pass to the constructor",36,null],[11,"server","","Create a new websocket Loop (server-side)",37,{"inputs":[{"name":"writeframed"},{"name":"readframed"},{"name":"t"},{"name":"d"},{"name":"arc"}],"output":{"name":"loop"}}],[11,"client","","Create a new websocket Loop (client-side)",37,{"inputs":[{"name":"writeframed"},{"name":"readframed"},{"name":"t"},{"name":"d"},{"name":"arc"}],"output":{"name":"loop"}}],[11,"closing","","A websocket loop that sends failure and waits for closing handshake",37,{"inputs":[{"name":"writeframed"},{"name":"readframed"},{"name":"u16"},{"name":"str"},{"name":"arc"}],"output":{"name":"loop"}}],[11,"poll","","",37,null],[11,"fmt","","",38,null],[11,"fmt","","",38,null],[11,"from","","",38,{"inputs":[{"name":"errorenum"}],"output":{"name":"self"}}],[11,"description","","",38,null],[11,"cause","","",38,null],[11,"custom","","Create an error instance wrapping custom error",38,{"inputs":[{"name":"e"}],"output":{"name":"error"}}],[11,"new","","Create a new (random) key, eligible to use for client connection",39,{"inputs":[],"output":{"name":"key"}}],[11,"from_key_bytes","","Create an Accept header value from a key received in header",40,null],[11,"fmt","","",40,null],[11,"fmt","","",40,null],[11,"fmt","","",39,null],[11,"fmt","","",39,null],[11,"fmt","","",33,null],[11,"clone","","",33,null],[11,"into","","",33,null],[0,"client","","Websocket client implementation",null,null],[3,"Encoder","tk_http::websocket::client","This a request writer that you receive in `Codec`",null,null],[3,"EncoderDone","","This structure returned from `Encoder::done` and works as a continuation\nthat should be returned from the future that writes request.",null,null],[3,"Head","","A borrowed structure that represents response headers",null,null],[3,"HandshakeProto","","A future that resolves to framed streams when websocket handshake is done",null,null],[3,"SimpleAuthorizer","","Default handshake handler, if you just want to get websocket connected",null,null],[8,"Authorizer","","Authorizer sends all the necessary headers and checks response headers\nto establish websocket connection",null,null],[16,"Result","","The type that may be returned from a `header_received`. It should\nencompass everything parsed from input headers.",41,null],[10,"write_headers","","Write request headers",41,null],[10,"headers_received","","A handler of response headers",41,null],[11,"fmt","","",42,null],[11,"new","","Create a new authorizer that sends specified host and path",43,{"inputs":[{"name":"a"},{"name":"b"}],"output":{"name":"simpleauthorizer"}}],[11,"write_headers","","",43,null],[11,"headers_received","","",43,null],[11,"request_line","","Write request line.",44,null],[11,"add_header","","Add a header to the websocket authenticatin data",44,null],[11,"format_header","","Same as `add_header` but allows value to be formatted directly into\nthe buffer",44,null],[11,"done","","Finish writing headers and return `EncoderDone` which can be moved to",44,null],[11,"new","","Create an instance of future from already connected socket",45,{"inputs":[{"name":"s"},{"name":"a"}],"output":{"name":"handshakeproto"}}],[11,"poll","","",45,null],[11,"status","","Returns status if it is one of the supported statuses otherwise None",42,null],[11,"raw_status","","Returns raw status code and reason as received even",42,null],[11,"all_headers","","All headers of HTTP request",42,null],[17,"GUID","tk_http::websocket","WebSocket GUID constant (provided by spec)",null,null],[8,"Dispatcher","","Dispatches messages received from websocket",null,null],[16,"Future","","Future returned from `frame()`",46,null],[10,"frame","","A frame received",46,null],[11,"fmt","","",36,null],[11,"clone","","",36,null],[11,"fmt","tk_http","",1,null],[11,"eq","","",1,null],[11,"clone","","",1,null],[11,"code","","Returns 3 digit numeric code",1,null],[11,"reason","","Returns title for the status code",1,null],[11,"response_has_body","","Returns true if sending body is expected for such status code",1,null],[11,"from","","Make Status from u16 if known code is passed.",1,{"inputs":[{"name":"u16"}],"output":{"name":"option"}}],[11,"fmt","","",0,null],[11,"clone","","",0,null],[11,"eq","","",0,null],[11,"fmt","","",0,null],[11,"hijack","tk_http::server","Called after future retunrted by `start_response` done if recv mode\nis `Hijack`",20,null]],"paths":[[4,"Version"],[4,"Status"],[3,"WebsocketHandshake"],[4,"RequestTarget"],[3,"Config"],[3,"Error"],[3,"Proto"],[3,"RawBody"],[3,"Encoder"],[3,"FutureRawBody"],[3,"Head"],[3,"HeaderIter"],[3,"RecvMode"],[8,"NewService"],[8,"Service"],[3,"Request"],[3,"WebsocketFactory"],[3,"WebsocketService"],[3,"BufferedDispatcher"],[3,"BufferedCodec"],[8,"Codec"],[8,"Dispatcher"],[3,"Config"],[3,"Encoder"],[3,"Error"],[3,"Head"],[3,"Proto"],[3,"RecvMode"],[3,"Response"],[3,"Buffered"],[8,"Client"],[8,"Codec"],[4,"Packet"],[4,"Frame"],[3,"ServerCodec"],[3,"ClientCodec"],[3,"Config"],[3,"Loop"],[3,"Error"],[3,"Key"],[3,"Accept"],[8,"Authorizer"],[3,"Head"],[3,"SimpleAuthorizer"],[3,"Encoder"],[3,"HandshakeProto"],[8,"Dispatcher"]]};
initSearch(searchIndex);
